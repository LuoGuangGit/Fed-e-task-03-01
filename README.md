## 一、简答题
### 1、当我们点击按钮的时候动态给 data 增加的成员是否是响应式数据，如果不是的话，如何把新增成员设置成响应式数据，它的内部原理是什么。
```JavaScript
let vm = new Vue({
  el: '#el'
  data: {
    o: 'object',
    dog: {}
  },
  method: {
    clickHandler () {
      // 该 name 属性是否是响应式的
      this.dog.name = 'Trump'
    }
  }
})
```
答：不是响应式数据，设置成响应式数据代码如下：
> vue 使用 Object.defineProperty 将传递给 vue 示例的 JavaScript 对象中的数据转换成 getter/setter 以此监听数据更改响应式，在传递时数据需要初始化，否则后添加的数据没有转换成 getter/setter 因此后添加的数据不会被监听，因此不会在数据修改时视图自定更新
```JavaScript
let vm = new Vue({
  el: '#el'
  data: {
    o: 'object',
    dog: {
      name: '' // 初始化 name 设置响应式数据
    }
  },
  method: {
    clickHandler () {
      // 该 name 属性是否是响应式的
      this.dog.name = 'Trump'
    }
  }
})
```

### 2、请简述 Diff 算法的执行过程
1. patch 函数执行：
   * 通过判断节点的 sel 属性是否为 undefined （不为 undefined 为虚拟节点）来获取几点是真实 dom 还是虚拟 dom 如果是真实 dom 那么会把它转换成一个空的虚拟 dom
   * 判断两个虚拟节点是否是相同节点，如果是相同节点，那么调用 patchVnode 函数找差异并更新 dom，如果不是将新节点替换旧节点，并将旧节点从文档中移除
2. patchVnode 函数执行：
   * 判断是否传入 prepatch 钩子函数，传入则执行；判断新老节点内存地址是否相同，相同则直接 return 如果不相同则判断 data 是否是 undefined 如果为 false 则遍历执行模块的 update 函数，再判断用户是否设置 update 钩子函数，有则执行
   * 对比新旧 vnode 节点：判断 vnode.text 是否有值
     * 未定义：
       * 判断老节点和新节点是否都有子节点，如果都有定义那么判断新老节点的是否不相同，如果不相同那么调用 updateChildren 对比新旧节点的子节点
       * 如果新节点的子节点有定义，老节点没有定义，那么再判断老节点是否有文本内容，如果有那么清空 dom 元素的内容然后把新节点增加的子节点添加到界面上去
       * 如果老节点的子节点有定义而新节点的子节点没有定义，那么把老节点的子节点从界面上移除
       * 判断老节点中是否设置了 text 如果老节点有新节点没有那么对应的 dom 元素的内容清除
     * 新节点有值且不等于老节点的 text => 更新 dom 元素中的文本内容，更新前判断：判断老节点中是否有子节点，如果有那么将老节点对应的 dom 节点移除，然后再新节点的 text 更新到界面上去
   * 节点对比完后执行用户传入的 postpatch 钩子函数
3. updateChildren 函数执行：diff 算法核心，对比新旧节点所有子节点 children 然后找到节点的差异更新到 dom（一般不会将父节点更新或移动到字节点位置，因此只需要同级别子节点对比就行了）
   * 在进行同级别比较时，会对新老节点数组的开始和结尾节点设置索引，在遍历过程中移动相应的索引
   * 在对开始和结束节点比较时，有四种情况：
     * 旧开始节点和新开始节点比较：
       * 使用 sameVnode 比较它们的 key 和 sel 是否相同，相同的话调用 patchVnode 对比节点差异再更新到 dom 上，比较完之后将索引移动到下一个位置再比较后面这两个节点是否是相同节点，是的话调用 patchVnode，如果不相等，会比较旧的结束节点和新的结束节点
     * 旧结束节点和新结束节点比较：与上述比较类似
     * 旧开始节点和新结束节点比较：
       * 调用 sameVnode 判断节点是否相同，相同则调用 patchVnode 比较节点差异然后更新到 dom 上，然后将旧的开始节点对应的元素移动到最后，移动完之后会将旧的开始索引会移动到下一个位置，新的结束索引会移动到前一个位置
     * 旧结束节点和新开始节点比较：
       * 调用 sameVnode 判断节点是否相同，相同则调用 patchVnode 比较节点差异然后更新到 dom 上，然后将旧的结束节点对应的元素移动到最前面，移动完之后会将旧的结束索引会移动到前一个位置，新的开始索引会移动到下一个位置
   * 如果以上四种情况都不满足：
     * 在旧节点中循环遍历，寻找与新开始节点的 key 相同的节点：
       * 如果没有找到：说明新的开始节点是一个新的节点，那么创建对应的 dom 元素并且插入到节点数组的最前面
       * 如果找到：判断找的节点之间的 sel 选择器是否相同
         * 如果不相同：说明节点被修改了，那么它就是一个新的节点，那么此时重新创建对应的 dom 元素，插入到节点数组的最前面
         * 如果相同：那么将找到的节点移动到最前面
     * 循环结束：有两种情况：
       * 老节点的数组个数 < 新节点的数组个数：此时新节点数组中会有一些剩余，这些剩余节点就是要新增的节点，将它们插入到老节点数组的末尾
       * 老节点的数组个数 > 新节点的数组个数：此时老节点数组中会有一些剩余，这些剩余节点就是要删除的节点，把这些剩余节点批量删除

## 二、编程题
### 1、模拟 VueRouter 的 hash 模式的实现，实现思路和 History 模式类似，把 URL 中的 # 后面的内容作为路由的地址，可以通过 hashchange 事件监听路由地址的变化。
### 2、在模拟 Vue.js 响应式源码的基础上实现 v-html 指令，以及 v-on 指令。
### 3、参考 Snabbdom 提供的电影列表的示例，利用Snabbdom 实现类似的效果，如图：
![movie-list](./assets/movie-list.png)